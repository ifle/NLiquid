using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra;
using Nitra.Declarations;
using Nitra.Runtime;

using NLiquid.Parser.Ast;

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;

namespace NLiquid
{
  public module Utils
  {
  	public ResolveCall(func : Ref[DeclarationSymbol], arg0Type : TypeSymbol, argsTypes : ImmutableArray[TypeSymbol]) : Ref[FunSymbol]
  	{
  		def argCount = argsTypes.Length + 1;
  		def args = array(argCount);
  		args[0] = arg0Type;
  		argsTypes.CopyTo(args, 1);
  		def resolve(symbol : FunSymbol) : bool
  		{
  			if (symbol.IsParametersEvaluated && symbol.Parameters.Length == argCount)
  				// проверяем, что каждый аргумент 'a' является подтипом параметра 'p' с соответствующим индексом.
  				symbol.Parameters.ForAll2(args, (a, p) => NLiquidTypeUnifier.Instance.TryRequire(p, a))
  			else
  				false
  		}
  		func.Resolve(resolve)
  	}
  }
}
