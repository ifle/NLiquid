using System.Threading;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Extensions;
using Nemerle.Imperative;

using Nitra;
using Nitra.Declarations;
using Nitra.ProjectSystem;

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Reflection;

using NLiquid.Filters;
using NLiquid.Parser;
using NLiquid.Parser.Ast;

[assembly: ProjectSupport("NLiquid", typeof(NLiquid.ProjectSupport))]

namespace NLiquid
{
	class ProjectSupport : IProjectSupport
	{
		[Record]
		private class ProjectData
		{
			public Context : NLiquidDependentPropertyEvalContext;
			public Root    : RootSymbol;
		}

		static NoLocation : Location       = Location(SourceSnapshot.Default.File, NSpan(0));
		static NoFile : ProjectSystem.File = SourceSnapshot.Default.File;
		static NoSpan : NSpan              = NSpan(0);

		public RefreshReferences(cancellationToken : System.Threading.CancellationToken, project : Nitra.ProjectSystem.Project) : object
		{
			IgnoreParams();
			def root = RootSymbol() <-
			{
				FullName = "<root>";
				Kind = "root";
			};
			root.AddDeclaration(ExternalDeclaration.[RootSymbol](Name(NoLocation, "<root>")));

			def defineSymbol[Type](name : string, putToRootScope: bool = true) : Type where Type: DeclarationSymbol
			{
        def name = Name(NoLocation, name);
        def symbol =
          if (putToRootScope)
            ExternalDeclaration.[Type](name).DefineSymbol(root.MemberTable)
          else
            ExternalDeclaration.[Type](name).DefineSymbol();
        symbol
			}
			def nilSymbol        = defineSymbol.[NilSymbol]("nil"); // данный символ не нужен
			def doubleSymbol     = defineSymbol.[DoubleSymbol]("double");
			def intSymbol        = defineSymbol.[IntSymbol]("int");
			def boolSymbol       = defineSymbol.[BooleanSymbol]("bool");
			def stringSymbol     = defineSymbol.[StringSymbol]("string");
			def objectSymbol     = defineSymbol.[ObjectSymbol]("object"); // символ должен описывать списко членов (свойств)
			def dictionarySymbol = defineSymbol.[DictionarySymbol]("dictionary");

			def typeToSymbol(type : System.Type) : TypeSymbol
			{
				match (Type.GetTypeCode(type))
				{
					| TypeCode.Boolean => boolSymbol
					| TypeCode.Int32   => intSymbol
					| TypeCode.Double  => doubleSymbol
					| TypeCode.String  => stringSymbol
					// здесь надо добавить остальны е поддерживаемее типы
					| _ => null
				}
			}
			def functions = List();
      foreach (type when type.IsClass && type.GetCustomAttribute.[FilterContainerAttribute]() != null in Assembly.GetExecutingAssembly().GetTypes())
		  foreach (methodInfo in type.GetMethods(BindingFlags.Public | BindingFlags.Static))
			{
    		def attrs = methodInfo.GetCustomAttributesData();
    		foreach (attr when attr.AttributeType == typeof(FilterContainerAttribute) in attrs)
    		{
    			def filterName = attr.ConstructorArguments[0].Value :> string;
	        def name       = Name(NoLocation, filterName);
          def funSymbol  = FilterFunDeclaration(name, methodInfo).DefineSymbol(root.MemberTable) :> FunSymbol;
					funSymbol.Parameters = methodInfo.GetParameters().Select(p => typeToSymbol(p.ParameterType)).ToImmutableArray();
					funSymbol.Result     = typeToSymbol(methodInfo.ReturnType);
					functions.Add(funSymbol);
    		}
			}

			def context = NLiquidDependentPropertyEvalContext(nilSymbol, intSymbol, doubleSymbol, boolSymbol, stringSymbol, objectSymbol, dictionarySymbol,
																										 functions.ToArray());

			ProjectData(context, root)
		}

		public RefreshProject(cancellationToken : System.Threading.CancellationToken, files : System.Collections.Immutable.ImmutableArray[Nitra.Declarations.FileEvalPropertiesData], data : object) : void
		{
			def (context, root) = DecomposeData(data);
			context.CancellationToken = cancellationToken;

			when (cancellationToken.IsCancellationRequested)
				return;

			def scope = root.MemberTable;

			foreach (file in files)
				when (file.Ast is CompilationUnit as cu)
					cu.Scope = scope;

			def evalHost = ProjectEvalPropertiesHost(files, context.PredefinedSymbols);
			evalHost.EvalProperties(context, "Pass0", 0);
			evalHost.EvalProperties(context, "Pass1", 1);
		}

		public DeconstructType(symbol : Nitra.Declarations.DeclarationSymbol, _type : out Nitra.Declarations.TypeSymbol, typeArgs : out System.Collections.Immutable.ImmutableArray[Nitra.Declarations.TypeSymbol]) : bool
		{
			IgnoreParams();
			false
		}

		public GetSymbolById(data : object, symbolId : int) : ValueOption[Nitra.Declarations.DeclarationSymbol]
		{
			IgnoreParams();
			VNone()
		}

		public VisitGlobalSymbols(data : object, callback : System.Predicate[Nitra.Declarations.DeclarationSymbol]) : void
		{
			IgnoreParams();
		}

		DecomposeData(data : object) : ProjectData
		{
			data :> ProjectData
		}
	}
}
