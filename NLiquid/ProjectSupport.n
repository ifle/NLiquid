using System.Threading;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Extensions;
using Nemerle.Imperative;

using Nitra;
using Nitra.Declarations;
using Nitra.ProjectSystem;

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;

using NLiquid.Parser;
using NLiquid.Parser.Ast;
using NLiquid.Filters;

[assembly: ProjectSupport("NLiquid", typeof(NLiquid.ProjectSupport))]

namespace NLiquid
{
	class ProjectSupport : IProjectSupport
	{
		[Record]
		private class ProjectData
		{
			public Context : NLiquidDependentPropertyEvalContext;
			public Root    : RootSymbol;
		}

		static NoLocation : Location       = Location(SourceSnapshot.Default.File, NSpan(0));
		static NoFile : ProjectSystem.File = SourceSnapshot.Default.File;
		static NoSpan : NSpan              = NSpan(0);

		public RefreshReferences(cancellationToken : System.Threading.CancellationToken, project : Nitra.ProjectSystem.Project) : object
		{
			IgnoreParams();
			def root = RootSymbol() <-
			{
				FullName = "<root>";
				Kind = "root";
			};
			root.AddDeclaration(ExternalDeclaration.[RootSymbol](Name(NoLocation, "<root>")));			
      
			def globalTypes     = NLiquidGlobalTypes(root.MemberTable);
			def filters         = FilterTypes.Create(root.MemberTable, globalTypes);
			def predefinedTypes = PredefinedTypes(globalTypes, filters);
			def context         = NLiquidDependentPropertyEvalContext(predefinedTypes);
			
			ProjectData(context, root)
		}

		public RefreshProject(cancellationToken : CancellationToken, files : ImmutableArray[FileEvalPropertiesData], data : object) : void
		{
			def (context, root) = DecomposeData(data);
			context.CancellationToken = cancellationToken;

			when (cancellationToken.IsCancellationRequested)
				return;

			def scope = root.MemberTable;

			foreach (file in files)
				when (file.Ast is CompilationUnit as cu)
					cu.Scope = scope;

			def evalHost = ProjectEvalPropertiesHost(files, context.PredefinedTypes.Symbols);
			evalHost.EvalProperties(context, "Pass0", 0);
			evalHost.EvalProperties(context, "Pass1", 1);
		}

		public DeconstructType(symbol : DeclarationSymbol, _type : out TypeSymbol, typeArgs : out ImmutableArray[TypeSymbol]) : bool
		{
			IgnoreParams();
			false
		}

		public GetSymbolById(data : object, symbolId : int) : ValueOption[DeclarationSymbol]
		{
			IgnoreParams();
			VNone()
		}

		public VisitGlobalSymbols(data : object, callback : Predicate[DeclarationSymbol]) : void
		{
			IgnoreParams();
		}

		DecomposeData(data : object) : ProjectData
		{
			data :> ProjectData
		}
	}
}
