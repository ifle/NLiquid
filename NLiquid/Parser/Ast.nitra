using Nitra;
using Nitra.Declarations;
using Nitra.Runtime;
using NLiquid;
using System.IO;

namespace NLiquid.Parser.Ast
{
	ast CompilationUnit
	{
		in MemberTable : TableScope;
		Statements : Statement*;
	}	
  
	abstract ast Statement : BindableAst
	{
		in CurrentTable : TableScope;
		
		| Plain  { }
		| Comment { }
		| Output { Expr : Expr; }
		| If 
		 { 	
			Body.CurrentTable = CurrentTable;
			ElseIfs.CurrentTable = CurrentTable;
			Else.CurrentTable = CurrentTable;
			
			Condition : Expr;
			Body      : Statement*; 
			ElseIfs   : ElseIf*;
			Else      : Else?;
		 }
		| Unless 
		 { 	
			Body.CurrentTable = CurrentTable;
			
			Condition : Expr;
			Body      : Statement*; 			
		 }
	}

	ast ElseIf 
	{  
		in CurrentTable : TableScope;
		Body.CurrentTable = CurrentTable;
		
		Condition : Expr; 
		Body : Statement*;  
	}
	ast Else  
	{ 
		in CurrentTable : TableScope;
		
		Body: Statement*; 
	}	

	declaration Assignment : Statement
	{
		Initializer : Expr;
	}	
	abstract ast Binary : Expr
	{ 
		Expr1 : Expr;
		Expr2 : Expr; 
	}
	
	abstract ast EqualExpr : Binary
	{
		
	}
	
	abstract ast OrAndExpr : Binary
	{

	}	
	abstract ast ContainsExpr : Binary
	{

	}
	
	abstract ast Expr : BindableAst
	{
		| SStr         { Value : string; }
		| DStr         { Value : string; }
		| Ref          { Reference : Reference; }
		| MemberAccess { Qualifier : Expr; Reference : Reference; }
		| Error        { Error(context, "Expected: Expr '}}'"); }
		| Call         { Func : Expr; Args : Expr*; }
		| Or           : OrAndExpr {}
		| And          : OrAndExpr {}
		| Contains     : ContainsExpr {}
		| Equal        : EqualExpr{ }
		| NotEqual     : EqualExpr{ }
	}
}
