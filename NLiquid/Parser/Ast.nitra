using Nitra;
using Nitra.Declarations;
using Nitra.Runtime;
using NLiquid;
using System.IO;

namespace NLiquid.Parser.Ast
{
	ast CompilationUnit : BindableAst, LocalVariableScope
	{
		Statements.CurrentTable = LocalVariables;
		Statements.Scope = Scope.HideWith(LocalVariables);

		Statements : Statement*;
	}

	abstract ast LocalVariableScope
	{
		out LocalVariables : TableScope = TableScope("Local variables");
	}

	abstract ast Statement : BindableAst
	{
		in CurrentTable : TableScope;

		| Plain  { }
		| Comment { }
		| Output
		 {
			Expr.Scope = Scope;

			Expr : Expr;
		 }
		| If : LocalVariableScope
		 {
			CurrentTable         = LocalVariables;
			// протаскиваем текущую таблицу имен во вложенные блоки
			Body.CurrentTable    = CurrentTable;
			ElseIfs.CurrentTable = CurrentTable;
			Else.CurrentTable    = CurrentTable;
			Body.Scope           = Scope.HideWith(LocalVariables); // скрываем скопом локальных переменных скопы сформированные выше.
			Condition.Scope      = Scope;
			ElseIfs.Scope        = Scope;
			Else.Scope           = Scope;

			Condition : Expr;
			Body      : Statement*;
			ElseIfs   : ElseIf*;
			Else      : Else?;
		 }
		| Unless : LocalVariableScope
		 {
			CurrentTable      = LocalVariables;
			Body.CurrentTable = CurrentTable;
			Body.Scope        = Scope.HideWith(LocalVariables);
			Condition.Scope   = Scope;

			Condition : Expr;
			Body      : Statement*;
		 }
	}

	ast ElseIf : Statement, LocalVariableScope
	{
		CurrentTable      = LocalVariables;
		Body.CurrentTable = CurrentTable;
		Body.Scope        = Scope.HideWith(LocalVariables);
		Condition.Scope   = Scope;

		Condition : Expr;
		Body      : Statement*;
	}

	ast Else : Statement, LocalVariableScope
	{
		CurrentTable      = LocalVariables;
		Body.CurrentTable = CurrentTable;
		Body.Scope        = Scope.HideWith(LocalVariables);

		Body: Statement*;
	}

	declaration Assignment : Statement
	{		
		symbol
		{
			in Type: TypeSymbol;
			Kind = "assigment";
		}
		
		ContainingTable   = CurrentTable; // говорим в какой таблице определять переменную
		Initializer.Scope = Scope;
		Symbol.Type       = Initializer.Type;

		Initializer : Expr;
		
	}

	abstract ast Binary : Expr
	{
		Expr1.Scope = Scope;
		Expr2.Scope = Scope;

		Expr1 : Expr;
		Expr2 : Expr;
	}

	abstract ast SameTypesExpr : Binary
  	{
		unless (NLiquidTypeUnifier.Instance.TryUnify(Expr1.Type, Expr2.Type))
			Expr2.Error(context, $"$(self.Expr2.Type) is not compatible with $(self.Expr1.Type).");
  	}

	abstract ast EqualExpr : SameTypesExpr
	{
		Type = context.GetBooleanSymbol();
	}

	abstract ast OrAndExpr : SameTypesExpr
	{
		Type = context.GetBooleanSymbol();    
	}

	abstract ast ContainsExpr : SameTypesExpr
	{
		Type = context.GetBooleanSymbol();
    
		unless (NLiquidTypeUnifier.Instance.TryUnify(Expr1.Type, context.GetStringSymbol()))
			Expr1.Error(context, $"Expected string expression but found $(self.Expr1.Type).");
	}

	abstract ast Expr : BindableAst
	{
		in Type: TypeSymbol = context.GetNilSymbol();
    	in ExpectedType: TypeSymbol = NLiquidTypeUnifier.Instance.CreateTypeVar();    	

		unless (NLiquidTypeUnifier.Instance.TryUnify(Type, ExpectedType))
			Error(context, $"Expected $(self.ExpectedType) but got $(self.Type)");


		| True
		  {
			Type = context.GetBooleanSymbol();
        	Value : bool; 
		  }
		| False
		  {
			Type = context.GetBooleanSymbol();
        	Value : bool; 
		  }
		| SStr         
		  { 
			Type = context.GetStringSymbol();
			Value : string;
		 }
		| DStr
		  { 
			Type = context.GetStringSymbol();
			Value : string;
		 }
		| Ref
		 {
			out Ref: Ref[AssignmentSymbol] = Reference.Ref.Resolve();
			Reference.Scope = Scope;
			Type = Ref.Symbol.Type;
			Reference : Reference;
		 }
		| MemberAccess
		 {
			Qualifier.Scope = Scope;
			Reference.Scope = Scope;

			Qualifier : Expr;
			Reference : Reference;
		 }
		| Error        { Error(context, "Expected: Expr '}}'"); }
		| Call
		 {
			Func.Scope = Scope;
			Args.Scope = Scope;

			Func : Expr;
			Args : Expr*;
		 }
		| Or           : OrAndExpr {}
		| And          : OrAndExpr {}
		| Contains     : ContainsExpr {}
		| Equal        : EqualExpr{ }
		| NotEqual     : EqualExpr{ }
	}

	abstract ast TypeReference
	{
		in Type: TypeSymbol;

		| Nil        { Type = context.GetNilSymbol();        }
		| Number     { Type = context.GetNumberSymbol();     }
		| Boolean    { Type = context.GetBooleanSymbol();    }
		| String     { Type = context.GetStringSymbol();     }
		| Object     { Type = context.GetObjectSymbol();     }
		| Array      { Type = context.GetArraySymbol();      }
		| Dictionary { Type = context.GetDictionarySymbol(); }
	}

	declaration Root        : Container {}

	declaration Nil         : Type {}
 	declaration Number      : Type {}
  	declaration Boolean     : Type {}
  	declaration String      : Type {}
	declaration Object      : Type {}
	declaration Array       : Type {}
	declaration Dictionary  : Type {}
}
