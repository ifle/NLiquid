using Nitra;
using Nitra.Declarations;
using Nitra.Runtime;
using NLiquid;
using System.IO;

namespace NLiquid.Parser.Ast
{
	ast CompilationUnit
	{
		in MemberTable : TableScope;
		Statements.CurrentTable = MemberTable;		
		Statements : Statement*;
	}		
	
	abstract ast Statement : BindableAst
	{		
		in CurrentTable : TableScope;
		Scope = TableScope("locals");

		| Plain  { }
		| Comment { }
		| Output 
		 { 
			Expr.Scope = Scope;
			Expr : Expr; 
		}
		| If 
		 { 	
			Condition.Scope			= Scope;
			Body.CurrentTable 		= Scope :> TableScope;
			ElseIfs.CurrentTable 	= Scope :> TableScope;
			Else.CurrentTable 		= Scope :> TableScope;			
			
			Condition : Expr;
			Body      : Statement*; 
			ElseIfs   : ElseIf*;
			Else      : Else?;
		 }
		| Unless 
		 { 	
			Body.CurrentTable = Scope :> TableScope;
			Condition.Scope	= Scope;
			Condition : Expr;
			Body      : Statement*; 			
		 }
	}

	ast ElseIf 
	{  
		in CurrentTable : TableScope;
		in Scope : TableScope;

		Scope = TableScope("locals");
		Body.CurrentTable = Scope;
		Condition.Scope	= CurrentTable;
		Condition : Expr; 
		Body : Statement*;  
	}
	ast Else  
	{ 
		in CurrentTable : TableScope;
		in Scope : TableScope;
		Scope = TableScope("locals");

		Body.CurrentTable = Scope;
		Body: Statement*; 
	}	

	declaration Assignment : Statement
	{
		ContainingTable = CurrentTable;
		Scope = CurrentTable;
		Initializer.Scope = Scope;
		Initializer : Expr;
	}	
	abstract ast Binary : Expr
	{ 
		Expr1.Scope = Scope;
		Expr2.Scope = Scope;
		
		Expr1 : Expr;
		Expr2 : Expr; 
	}
	
	abstract ast EqualExpr : Binary
	{
		
	}
	
	abstract ast OrAndExpr : Binary
	{

	}	
	abstract ast ContainsExpr : Binary
	{

	}
	
	abstract ast Expr : BindableAst
	{
		| SStr         { Value : string; }
		| DStr         { Value : string; }
		| Ref          
		 { 
			Reference.Scope = Scope;
			Reference : Reference; 
		 }
		| MemberAccess 
		 { 
			Qualifier.Scope = Scope;
			Reference.Scope = Scope;
			Qualifier : Expr; 
			Reference : Reference; 
		 }
		| Error        { Error(context, "Expected: Expr '}}'"); }
		| Call         
		 { 
			Func.Scope = Scope;
			Args.Scope = Scope;
			Func : Expr; 
			Args : Expr*; 
		 }
		| Or           : OrAndExpr {}
		| And          : OrAndExpr {}
		| Contains     : ContainsExpr {}
		| Equal        : EqualExpr{ }
		| NotEqual     : EqualExpr{ }
	}
}
