using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra;
using Nitra.Declarations;
using Nitra.Runtime;

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;

using NLiquid.Parser.Ast;

namespace NLiquid
{
	module AstUtils
	{
		public GetNilSymbol(this ctx: DependentPropertyEvalContext): NilSymbol               { GetContext(ctx).Nil        }
		public GetNumberSymbol(this ctx: DependentPropertyEvalContext): NumberSymbol         { GetContext(ctx).Number     }
		public GetBooleanSymbol(this ctx: DependentPropertyEvalContext): BooleanSymbol       { GetContext(ctx).Boolean    }
		public GetStringSymbol(this ctx: DependentPropertyEvalContext): StringSymbol         { GetContext(ctx).String     }
		public GetObjectSymbol(this ctx: DependentPropertyEvalContext): ObjectSymbol         { GetContext(ctx).Object     }
		public GetArraySymbol(this ctx: DependentPropertyEvalContext): ArraySymbol           { GetContext(ctx).Array      }
		public GetDictionarySymbol(this ctx: DependentPropertyEvalContext): DictionarySymbol { GetContext(ctx).Dictionary }

		GetContext(ctx: DependentPropertyEvalContext): NLiquidDependentPropertyEvalContext
		{
			ctx :> NLiquidDependentPropertyEvalContext
		}

		//// Hack: Nitra dependent property not support (yet) of indexer access.
		//public GetParameterType(func : FunDeclarationSymbol, index : int) : TypeSymbol
		//{
		//    def parameters = func.Parameters;
		//    if (index < parameters.Length && parameters[index].IsTypeEvaluated)
		//    parameters[index].Type
		//    else
		//    MiniCTypeUnifier.Instance.CreateTypeVar() // Use TypeVar to prevent phantom type mismatch error messages.
		//}

		public ResolveCall(func : Ref[DeclarationSymbol], arg0Type : TypeSymbol, argsTypes : ImmutableArray[TypeSymbol]) : Ref[FunSymbol]
		{
			def argCount = argsTypes.Length + 1; // '1' for arg0Type
			def args     = array(argCount);
			args[0] = arg0Type;
			argsTypes.CopyTo(args, 1);

			def resolve(symbol : FunSymbol) : bool
			{
				if (symbol.IsParametersEvaluated && symbol.Parameters.Length == argCount)
				// check that each argument type (a) is a subtype of the parameter type (p).
				symbol.Parameters.ForAll2(args, (a, p) => NLiquidTypeUnifier.Instance.TryRequire(p, a))
				else
				false
			}
			func.Resolve(resolve)
		}
	}
}
